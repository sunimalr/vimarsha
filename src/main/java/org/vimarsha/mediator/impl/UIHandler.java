/*
 *
 *  vimarsha, Performance analysis: Machine Learning Approach
 *  Copyright (C) 2013 vimarsha
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 * /
 */

package org.vimarsha.mediator.impl;

import org.jfree.data.category.DefaultCategoryDataset;
import org.jfree.data.xy.XYSeriesCollection;
import org.vimarsha.exceptions.ArchitectureNotSetException;
import org.vimarsha.exceptions.ClassificationFailedException;
import org.vimarsha.exceptions.TimestampNotFoundException;
import org.vimarsha.exceptions.TrainingModelNotSetException;
import org.vimarsha.mediator.Mediator;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;

/**
 * Created with IntelliJ IDEA.
 * User: sunimal
 */
public class UIHandler {
    private static UIHandler uiHandlerInstance = null;

    private Mediator mediator;

    public static UIHandler getInstance() {
        if (uiHandlerInstance == null) {
            uiHandlerInstance = new UIHandler();
        }
        return uiHandlerInstance;
    }

    private UIHandler() {
        this.mediator = new DefaultMediator();
    }

    /**
     * Set the processor architecture that the test and train data were collected on.
     *
     * @param architecture -Code string of the architecture (INTEL_NEHALEM ... etc)
     */
    public void setArchitecture(String architecture) {
        try {
            this.mediator.setArchitecture(architecture);
        } catch (Exception ex) {
            this.showErrorDialog("Architecture Not Set!");
        }
    }

    /**
     * Set the raw datafile that need to be converted to the ARFF format.
     *
     * @param file - Raw data file generated by vcollector or vtimecollector tool.
     * @return 100 on success, else -1
     */
    public int setRawFile(File file) {
        try {
            return this.mediator.setRawFile(file);
        } catch (Exception ex) {
            this.showErrorDialog("Raw file not set!");
            return -1;
        }
    }

    /**
     * Set the ARFF file that need to be evaluated.
     *
     * @param file -  ARFF file
     */
    public void setArffFile(File file) {
        try {
            this.mediator.setArffFile(file);
        } catch (IOException e) {
            this.showErrorDialog("ARFF File Not Set!");
        }
    }

    /**
     * Convert the raw data file to the ARFF format.
     *
     * @return 100 on success, else -1
     */
    public int convertRawToArff() {
        try {
            int res = this.mediator.convertRawFileToArff();
            if (res == 100) {
                this.showInfoDialog("File Conversion Successful!");
            }
            return res;
        } catch (Exception ex) {
            this.showErrorDialog("File Conversion Error!");
            return -1;
        }
    }

    /**
     * Save the generated ARFF file in the filesystem.
     *
     * @param fileToSave Destination of the file that should be saved.
     */
    public void saveAsArff(File fileToSave) {

        try {
            this.mediator.saveArffFile(fileToSave);
        } catch (IOException e) {
            this.showErrorDialog("File Save Failed!");
        }
    }

    /**
     * Get the list of ARFF attributes specified in the currently selected dataset.
     *
     * @return Arraylist containing the list of attributes
     */
    public ArrayList<String> getArffAttribiutesTableModel() {
        return this.mediator.getArffAttributesList();
    }

    /**
     * Get the plot data require to draw the attribute binned bar chart.
     *
     * @param selectedEvent - attribute that need to be analyzed
     * @return - DefaultCategoryDataset containing data for bar chart.
     */
    public DefaultCategoryDataset getBarChartDataSet(int selectedEvent) {
        try {
            return this.mediator.getBarChartDataSet(selectedEvent);
        } catch (IOException e) {
            this.showErrorDialog("Data source not set!");
        } catch (IllegalArgumentException e) {
        }
        return null;
    }

    /**
     * Get the available processor architecture list.
     *
     * @return Arraylist containing supported architectures
     */
    public ArrayList<String> getArchitectureList() {
        return this.mediator.getArchitectureList();
    }

    /**
     * Returns the currently selected architecture
     *
     * @return Currently selected architecture string
     */
    public String getArchitecture() {
        try {
            return this.mediator.getArchitecture();
        } catch (ArchitectureNotSetException e) {
            this.showErrorDialog(e.getMessage());
        }
        return null;
    }

    /**
     * Returns the currently selected training model.
     *
     * @return Currently selected training model string
     */
    public String getTrainingModel() {
        return this.mediator.getTrainingModel();
    }

    /**
     * Returns the currently selected test data set name
     *
     * @return Test data set name
     */
    public String getTestDataName() {
        return this.mediator.getTestDataName();
    }

    /**
     * Returns the list of available training models
     *
     * @return ArrayList containing list of available training models
     */
    public ArrayList<String> getTrainingModels() {
        return this.mediator.getTrainingModels();
    }

    /**
     * Classifies the currently seleted functionwise dataset.
     */
    public void classifyFunctionWise() {
        try {
            this.mediator.classifyFunctionWise();
        } catch (IOException e) {
            this.showErrorDialog("Data source not set!");
        } catch (ClassificationFailedException e) {
            this.showErrorDialog(e.getMessage());
        }
    }

    /**
     * Classifies the currently selected whole-program data instance.
     */
    public void classifyWholeProgram() {
        try {
            this.mediator.classifyWholeProgram();
        } catch (IOException e) {
            this.showErrorDialog("Data source not set!");
        } catch (ClassificationFailedException e) {
            this.showErrorDialog(e.getMessage());
        }
    }

    /**
     * Returns the list of buffered whole-program classification results' timestamps
     *
     * @return Arraylist containing the list of timestamps associated with whole-program classification results
     */
    public ArrayList<String> getWholeProgramTestSetList() {
        return mediator.getWholeProgramTimestamps();
    }

    /**
     * Classifies the timesliced test data set.
     */
    public void classifyTimeSliced() {
        try {
            this.mediator.classifyTimeSliced();
        } catch (IOException e) {
            this.showErrorDialog("Data source not set!");
        } catch (ClassificationFailedException e) {
            e.getMessage();
        }
    }

    /**
     * Returns the functionwise classification results
     *
     * @return Functionwise results as a table model
     */
    public DefaultTableModel getClassificationResults() {
        return this.mediator.getFunctionWiseClassificationResultsTableModel();
    }

    /**
     * Returns the chart plotting data to draw the scatter plot to illustrate timesliced classifications.
     *
     * @return JFreeChart XYSeriesCollection (scatter plot data)
     */
    public XYSeriesCollection getXYChartDataSet() {
        return this.mediator.getXYChartDataSet();
    }

    /**
     * Saves functionwise classification results as a CSV file
     *
     * @param file File save destination
     */
    public void exportFunctionWiseAsCSV(File file) {
        try {
            this.mediator.exportFunctionWiseResultsAsCSV(file);
        } catch (IOException e) {
            this.showErrorDialog("Please select the file destination!");
        }
    }

    /**
     * Saves timesliced classification results as a CSV file
     *
     * @param file File save destination
     */
    public void exportTimeSlicedAsCSV(File file) {
        try {
            this.mediator.exportTimeSlicedResultsAsCSV(file);
        } catch (IOException e) {
            this.showErrorDialog("Please select the file destination!");
        }
    }

    /**
     * Returns statistical data of an attribute
     *
     * @param attrNo - Attribute index
     * @return Table data with attribute's statistical data
     */
    public DefaultTableModel getArffAttributeInfo(int attrNo) {
        return mediator.getArffAttributeInfo(attrNo);
    }

    /**
     * Returns classification results of the currently selected whole-program data instance
     *
     * @param timestamp Timestamp of the classification result
     * @return String containing the classification result
     */
    public String getWholeProgramClassificationResult(String timestamp) {
        String tmp = null;
        try {
            tmp = mediator.getWholeProgramClassificationResult(timestamp);
        } catch (TimestampNotFoundException e) {
            this.showErrorDialog(e.getMessage());
        }
        return tmp;
    }

    /**
     * Displays an error message as a popup dialog box.
     *
     * @param errorMessage
     */
    private void showErrorDialog(String errorMessage) {
        JOptionPane.showMessageDialog(null, errorMessage, "Error", JOptionPane.ERROR_MESSAGE);
    }

    /**
     * Displays an information message as a popup dialog box.
     *
     * @param infoMessage
     */
    private void showInfoDialog(String infoMessage) {
        JOptionPane.showMessageDialog(null, infoMessage, "Info", JOptionPane.INFORMATION_MESSAGE);
    }
}
